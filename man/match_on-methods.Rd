% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/match_on.R
\docType{methods}
\name{match_on}
\alias{match_on}
\alias{match_on.glm}
\alias{match_on.bigglm}
\alias{match_on.formula}
\alias{match_on.function}
\alias{match_on.numeric}
\alias{match_on.InfinitySparseMatrix}
\alias{match_on.matrix}
\title{Create treated to control distances for matching problems}
\usage{
match_on(x, within = NULL, caliper = NULL, exclude = NULL, data = NULL, ...)

\method{match_on}{glm}(
  x,
  within = NULL,
  caliper = NULL,
  exclude = NULL,
  data = NULL,
  standardization.scale = NULL,
  ...
)

\method{match_on}{bigglm}(
  x,
  within = NULL,
  caliper = NULL,
  exclude = NULL,
  data = NULL,
  standardization.scale = NULL,
  ...
)

\method{match_on}{formula}(
  x,
  within = NULL,
  caliper = NULL,
  exclude = NULL,
  data = NULL,
  subset = NULL,
  method = "mahalanobis",
  ...
)

\method{match_on}{`function`}(
  x,
  within = NULL,
  caliper = NULL,
  exclude = NULL,
  data = NULL,
  z = NULL,
  ...
)

\method{match_on}{numeric}(x, within = NULL, caliper = NULL, exclude = NULL, data = NULL, z, ...)

\method{match_on}{InfinitySparseMatrix}(x, within = NULL, caliper = NULL, exclude = NULL, data = NULL, ...)

\method{match_on}{matrix}(x, within = NULL, caliper = NULL, exclude = NULL, data = NULL, ...)
}
\arguments{
\item{x}{A model formula, fitted glm or other object implicitly specifying a distance; see blurbs on specific methods in Details.}

\item{within}{A valid distance specification, such as the result of
\code{\link{exactMatch}} or \code{\link{caliper}}. Finite entries indicate
which distances to create. Including this argument can significantly speed
up computation for sparse matching problems. Specify this filter either via
\code{within} or via \code{strata} elements of a formula; mixing these
methods will fail.}

\item{caliper}{The width of a caliper to use to exclude treated-control pairs
with values greater than the width. For some methods, there may be a speed
advantage to passing a width rather than using the \code{\link{caliper}}
function on an existing distance specification.}

\item{exclude}{A list of units (treated or control) to exclude from the
\code{caliper} argument (if supplied).}

\item{data}{An optional data frame.}

\item{...}{Other arguments for methods.}

\item{standardization.scale}{Function for rescaling of \code{scores(x)}, or
\code{NULL}; defaults to \code{mad}. (See Details.)}

\item{subset}{A subset of the data to use in creating the distance
specification.}

\item{method}{A string indicating which method to use in computing the
distances from the data.  The current possibilities are
\code{"mahalanobis", "euclidean"} or \code{"rank_mahalanobis"}.}

\item{z}{A logical or binary vector indicating treatment and control for each
unit in the study. TRUE or 1 represents a treatment unit, FALSE of 0 represents
a control unit. Any unit with NA treatment status will be excluded from the
distance matrix.}
}
\value{
A distance specification (a matrix or similar object) which is
  suitable to be given as the \code{distance} argument to
  \code{\link{fullmatch}} or \code{\link{pairmatch}}.
}
\description{
A function with which to produce matching distances, for instance Mahalanobis
distances, propensity score discrepancies or calipers, or combinations
thereof, for \code{\link{pairmatch}} or \code{\link{fullmatch}} to
subsequently \dQuote{match on}.  Conceptually, the result of a call
\code{match_on} is a treatment-by-control matrix of distances.  Because these
matrices can grow quite large, in practice \code{match_on} produces either an
ordinary dense matrix or a special sparse matrix structure (that can make use
of caliper and exact matching constraints to reduce storage requirements).
Methods are supplied for these sparse structures,
\code{InfinitySparseMatrix}es, so that they can be manipulated and modified
in much the same way as dense matrices.
}
\details{
\code{match_on} is generic. There are several supplied methods, all providing
the same basic output: a matrix (or similar) object with treated units on the
rows and control units on the columns. Each cell [i,j] then indicates the
distance from a treated unit i to control unit j. Entries that are \code{Inf}
are said to be unmatchable. Such units are guaranteed to never be in a
matched set. For problems with many \code{Inf} entries, so called sparse
matching problems, \code{match_on} uses a special data type that is more
space efficient than a standard R \code{matrix}.  When problems are not
sparse (i.e. dense), \code{match_on} uses the standard \code{matrix} type.

\code{match_on} methods differ on the types of arguments they take, making
the function a one-stop location of many different ways of specifying
matches: using functions, formulas, models, and even simple scores. Many of
the methods require additional arguments, detailed below. All methods take a
\code{within} argument, a distance specification made using
\code{\link{exactMatch}} or \code{\link{caliper}} (or some additive
combination of these or other distance creating functions). All
\code{match_on} methods will use the finite entries in the \code{within}
argument as a guide for producing the new distance. Any entry that is
\code{Inf} in \code{within} will be \code{Inf} in the distance matrix
returned by \code{match_on}. This argument can reduce the processing time
needed to compute sparse distance matrices.

Details for each particular first type of argument follow:

\bold{First argument (\code{x}): \code{glm}.} The model is assumed to be
  a fitted propensity score model. From this it extracts distances on the
  \emph{linear} propensity score: fitted values of the linear predictor, the
  link function applied to the estimated conditional probabilities, as opposed
  to the estimated conditional probabilities themselves (Rosenbaum & Rubin,
  1985).  For example, a logistic model (\code{glm} with
  \code{family=binomial()}) has the logit function as its link, so from such
  models \code{match_on} computes distances in terms of logits of the
  estimated conditional probabilities, i.e. the estimated log odds.

  Optionally these distances are also rescaled. The default is to rescale, by
  the reciprocal of an outlier-resistant variant of the pooled s.d. of
  propensity scores; see \code{\link{standardization_scale}}.  (The
  \code{standardization.scale} argument of this function can be used to
  change how this dispersion is calculated, e.g. to calculate an ordinary not
  an outlier-resistant s.d.; it will be passed down
  to \code{standardization_scale} as its \code{standardizer} argument.)
  To skip rescaling, set argument \code{standardization.scale} to 1.
  The overall result records
  absolute differences between treated and control units on linear, possibly
  rescaled, propensity scores.

  In addition, one can impose a caliper in terms of these distances by
  providing a scalar as a \code{caliper} argument, forbidding matches between
  treatment and control units differing in the calculated propensity score by
  more than the specified caliper.  For example, Rosenbaum and Rubin's (1985)
  caliper of one-fifth of a pooled propensity score s.d. would be imposed by
  specifying \code{caliper=.2}, in tandem either with the default rescaling
  or, to follow their example even more closely, with the additional
  specification \code{standardization.scale=sd}. Propensity calipers are
  beneficial computationally as well as statistically, for reasons indicated
  in the below discussion of the \code{numeric} method.

  One can also specify exactMatching criteria by using \code{strata(foo)} inside
  the formula to build the \code{glm}. For example, passing
  \code{glm(y ~ x + strata(s))} to \code{match_on} is equivalent to passing
  \code{within=exactMatch(y ~ strata(s))}. Note that when combining with
  the \code{caliper} argument, the standard deviation used for the caliper will be
  computed across all strata, not within each strata.

  If data used to fit the glm have missing values in the left-hand side
  (dependent) variable, these observations are omitted from the output of
  match_on.  If there are observations with missing values in right hand
  side (independent) variables, then a re-fit of the model after imputing
  these variables using a simple scheme and adding indicator variables of
  missingness will be attempted, via the \code{\link{scores}} function.

\bold{First argument (\code{x}): \code{bigglm}.} This method works
  analogously to the \code{glm} method, but with \code{bigglm} objects,
  created by the \code{bigglm} function from package \sQuote{biglm}, which
  can handle bigger data sets than the ordinary glm function can.

\bold{First argument (\code{x}): \code{formula}.} The formula must have
  \code{Z}, the treatment indicator (\code{Z=0} indicates control group,
  \code{Z=1} indicates treatment group), on the left hand side, and any
  variables to compute a distance on on the right hand side. E.g. \code{Z ~ X1
  + X2}. The Mahalanobis distance is calculated as the square root of d'Cd,
  where d is the vector of X-differences on a pair of observations and C is an
  inverse (generalized inverse) of the pooled covariance of Xes. (The pooling
  is of the covariance of X within the subset defined by \code{Z==0} and
  within the complement of that subset. This is similar to a Euclidean
  distance calculated after reexpressing the Xes in standard units, such that
  the reexpressed variables all have pooled SDs of 1; except that it addresses
  redundancies among the variables by scaling down variables contributions in
  proportion to their correlations with other included variables.)

  Euclidean distance is also available, via \code{method="euclidean"}, and
  ranked, Mahalanobis distance, via \code{method="rank_mahalanobis"}.

  The treatment indicator \code{Z} as noted above must either be numeric
  (1 representing treated units and 0 control units) or logical
  (\code{TRUE} for treated, \code{FALSE} for controls). (Earlier versions of
  the software accepted factor variables and other types of numeric variable; you
  may have to update existing scripts to get them to run.)


  As an alternative to specifying a \code{within} argument, when \code{x} is
  a formula, the \code{strata} command can be used inside the formula to specify
  exact matching. For example, rather than using \code{within=exactMatch(y ~
  z, data=data)}, you may update your formula as \code{y ~ x + strata(z)}. Do
  not use both methods (\code{within} and \code{strata} simultaneously. Note
  that when combining with the \code{caliper} argument, the standard
  deviation used for the caliper will be computed across all strata, not
  separately by stratum.

  A unit with NA treatment status (\code{Z}) is ignored and will not be included in the distance output.
 Missing values in variables on the right hand side of the formula are handled as follows. By default
\code{match_on} will (1) create a matrix of distances between observations which
have only valid values for **all** covariates and then (2) append matrices of Inf values
for distances between observations either of which has a missing values on any of the right-hand-side variables.
(I.e., observations with missing values are retained in the output, but
matches involving them are forbidden.)

\bold{First argument (\code{x}): \code{function}.} The passed function
  must take arguments: \code{index}, \code{data}, and \code{z}. The
  \code{data} and \code{z} arguments will be the same as those passed directly
  to \code{match_on}. The \code{index} argument is a matrix of two columns,
  representing the pairs of treated and control units that are valid
  comparisons (given any \code{within} arguments). The first column is the row
  name or id of the treated unit in the \code{data} object. The second column
  is the id for the control unit, again in the \code{data} object. For each of
  these pairs, the function should return the distance between the treated
  unit and control unit.  This may sound complicated, but is simple to
  use. For example, a function that returned the absolute difference between
  two units using a vector of data would be \code{ f <- function(index, data,
  z) { abs(data[index[,1]] - data[index[,2]]) } }.  (Note: This simple case is
  precisely handled by the \code{numeric} method.)

\bold{First argument (\code{x}): \code{numeric}.} This returns
  absolute differences between treated and control units' values of \code{x}.
  If a caliper is specified, pairings with \code{x}-differences greater than
  it are forbidden.  Conceptually, those distances are set to \code{Inf};
  computationally, if either of \code{caliper} and \code{within} has been
  specified then only information about permissible pairings will be stored,
  so the forbidden pairings are simply omitted. Providing a \code{caliper}
  argument here, as opposed to omitting it and afterward applying the
  \code{\link{caliper}} function, reduces storage requirements and may
  otherwise improve performance, particularly in larger problems.

  For the numeric method, \code{x} must have names. If \code{z} is named
  it must have the same names as \code{x}, though it allows for a different
  ordering of names. \code{x}'s name ordering is considered canonical.

\bold{First argument (\code{x}): \code{matrix} or \code{InfinitySparseMatrix}.} These just return their
  arguments as these objects are already valid distance specifications.
}
\examples{
data(nuclearplants)
match_on.examples <- list()
### Propensity score distances.
### Recommended approach:
(aGlm <- glm(pr~.-(pr+cost), family=binomial(), data=nuclearplants))
match_on.examples$ps1 <- match_on(aGlm)
### A second approach: first extract propensity scores, then separately
### create a distance from them.  (Useful when importing propensity
### scores from an external program.)
plantsPS <- predict(aGlm)
match_on.examples$ps2 <- match_on(pr~plantsPS, data=nuclearplants)
### Full matching on the propensity score.
fm1 <- fullmatch(match_on.examples$ps1, data = nuclearplants)
fm2 <- fullmatch(match_on.examples$ps2, data = nuclearplants)
### Because match_on.glm uses robust estimates of spread,
### the results differ in detail -- but they are close enough
### to yield similar optimal matches.
all(fm1 == fm2) # The same

### Mahalanobis distance:
match_on.examples$mh1 <- match_on(pr ~ t1 + t2, data = nuclearplants)

### Absolute differences on a scalar:
tmp <- nuclearplants$t1
names(tmp) <- rownames(nuclearplants)

(absdist <- match_on(tmp, z = nuclearplants$pr,
                  within = exactMatch(pr ~ pt, nuclearplants)))

### Pair matching on the variable `t1`:
pairmatch(absdist, data = nuclearplants)


### Propensity score matching within subgroups:
match_on.examples$ps3 <- match_on(aGlm, exactMatch(pr ~ pt, nuclearplants))
fullmatch(match_on.examples$ps3, data = nuclearplants)

### Propensity score matching with a propensity score caliper:
match_on.examples$pscal <- match_on.examples$ps1 + caliper(match_on.examples$ps1, 1)
fullmatch(match_on.examples$pscal, data = nuclearplants) # Note that the caliper excludes some units

### A Mahalanobis distance for matching within subgroups:
match_on.examples$mh2 <- match_on(pr ~ t1 + t2 , data = nuclearplants,
                            within = exactMatch(pr ~ pt, nuclearplants))

### Mahalanobis matching within subgroups, with a propensity score
### caliper:
fullmatch(match_on.examples$mh2 + caliper(match_on.examples$ps3, 1), data = nuclearplants)

### Alternative methods to matching without groups (exact matching)
m1 <- match_on(pr ~ t1 + t2, data=nuclearplants, within=exactMatch(pr ~ pt, nuclearplants))
m2 <- match_on(pr ~ t1 + t2 + strata(pt), data=nuclearplants)
# m1 and m2 are identical

m3 <- match_on(glm(pr ~ t1 + t2 + cost, data=nuclearplants,
                   family=binomial),
               data=nuclearplants,
               within=exactMatch(pr ~ pt, data=nuclearplants))
m4 <- match_on(glm(pr ~ t1 + t2 + cost + pt, data=nuclearplants,
                   family=binomial),
               data=nuclearplants,
               within=exactMatch(pr ~ pt, data=nuclearplants))
m5 <- match_on(glm(pr ~ t1 + t2 + cost + strata(pt), data=nuclearplants,
                   family=binomial), data=nuclearplants)
# Including `strata(foo)` inside a glm uses `foo` in the model as
# well, so here m4 and m5 are equivalent. m3 differs in that it does
# not include `pt` in the glm.
}
\references{
P.~R. Rosenbaum and D.~B. Rubin (1985), \sQuote{Constructing a
  control group using multivariate matched sampling methods that incorporate
  the propensity score}, \emph{The American Statistician}, \bold{39} 33--38.
}
\seealso{
\code{\link{fullmatch}}, \code{\link{pairmatch}},
  \code{\link{exactMatch}}, \code{\link{caliper}}

\code{\link{scores}}
}
